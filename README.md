USE ZOMATO;
SELECT * FROM DATA;

-- ITS OBSERVED THAT DATA IS REDUNDANT.
-- THE DATA CAN BE NORMALIZED INTO FOUR TABLES (CITIES, RESTAURANTS, CUISINES AND ITEMS).

## TABLE "CITIES"
CREATE TABLE CITIES (
  CITY_ID INT AUTO_INCREMENT PRIMARY KEY,
  CITY_NAME VARCHAR(255) UNIQUE NOT NULL,
  AVG_PRICE_CITY DECIMAL(10, 4)
);

### INSERT INTO CITIES TABLE
INSERT INTO CITIES (CITY_NAME, AVG_PRICE_CITY)
SELECT DISTINCT CITY, AVG_PRICE_CITY
FROM DATA
WHERE CITY IS NOT NULL;

SELECT * FROM CITIES;

/*THIS TABLE SERVES AS A LOOKUP TABLE FOR UNIQUE CITIES. IT ELIMINATES REDUNDANCY BY STORING CITY-SPECIFIC INFORMATION (LIKE AVG_PRICE_CITY) JUST ONCE, RATHER THAN REPEATING IT FOR EVERY RESTAURANT LOCATED IN THAT CITY.*/

## TABLE "RESTAURANTS"
CREATE TABLE RESTAURANTS (
  RESTAURANT_ID INT AUTO_INCREMENT PRIMARY KEY,
  RESTAURANT_NAME VARCHAR(100),
  PLACE_NAME VARCHAR(100),
  DINING_RATING DECIMAL(3, 2),
  DINING_VOTES INT,
  DELIVERY_VOTES INT,
  DELIVERY_RATING DECIMAL(3, 2),
  AVG_RATING DECIMAL(3, 2),
  TOTAL_VOTES INT,
  RESTAURANT_POPULARITY INT,
  AVG_RATING_RESTAURANT DECIMAL(3, 2),
  AVG_PRICE_RESTAURANT DOUBLE,
  IS_HIGHLY_RATED INT,
  CITY_ID INT,
  FOREIGN KEY (CITY_ID) REFERENCES CITIES(CITY_ID)
);

### INSERT INTO RESTAURANTS TABLE
INSERT INTO RESTAURANTS (
  RESTAURANT_NAME, PLACE_NAME, DINING_RATING, DINING_VOTES, DELIVERY_VOTES, DELIVERY_RATING,
  AVG_RATING, TOTAL_VOTES, RESTAURANT_POPULARITY, AVG_RATING_RESTAURANT, AVG_PRICE_RESTAURANT,
  IS_HIGHLY_RATED, CITY_ID
)
SELECT DISTINCT(RESTAURANT_NAME), PLACE_NAME, DINING_RATING, DINING_VOTES, DELIVERY_VOTES,
  DELIVERY_RATING, AVERAGE_RATING, TOTAL_VOTES, RESTAURANT_POPULARITY, AVG_RATING_RESTAURANT,
  AVG_PRICE_RESTAURANT, IS_HIGHLY_RATED, CITY_ID
FROM DATA
JOIN CITIES AS C ON CITY = C.CITY_NAME;

SELECT * FROM RESTAURANTS;

/*THIS IS THE CORE TABLE FOR RESTAURANT DATA. IT IS NOW MORE EFFICIENT AS IT NO LONGER CONTAINS REDUNDANT CITY OR CUISINE INFORMATION. INSTEAD, IT USES FOREIGN KEYS (CITY_ID) TO LINK TO THE CITIES AND CUISINES TABLES, RESPECTIVELY. THIS STRUCTURE ENSURES DATA INTEGRITY AND SIMPLIFIES UPDATES.*/

## TABLE "CUISINES"
CREATE TABLE CUISINES (
  CUISINE_ID INT AUTO_INCREMENT PRIMARY KEY,
  CUISINE_NAME VARCHAR(100),
  AVG_RATING_CUISINE DECIMAL(3, 2),
  AVG_PRICE_CUISINE DOUBLE
);
### INSERT INTO CUISINES TABLE
INSERT INTO CUISINES (CUISINE_NAME, AVG_RATING_CUISINE, AVG_PRICE_CUISINE)
SELECT DISTINCT (CUISINE), AVG_RATING_CUISINE, AVG_PRICE_CUISINE
FROM DATA
WHERE CUISINE IS NOT NULL;

SELECT * FROM CUISINES;

/*SIMILAR TO THE CITIES TABLE, THIS TABLE CENTRALIZES ALL UNIQUE CUISINE TYPES. IT HOLDS AGGREGATE DATA LIKE AVG_RATING_CUISINE AND AVG_PRICE_CUISINE, PREVENTING THESE VALUES FROM BEING DUPLICATED ACROSS ALL MENU ITEMS BELONGING TO THE SAME CUISINE.*/

## TABLE "ITEMS"
CREATE TABLE ITEMS (
  ITEM_ID INT AUTO_INCREMENT PRIMARY KEY,
  ITEM_NAME VARCHAR(500),
  BEST_SELLER VARCHAR(50),
  VOTES INT,
  PRICE INT,
  PRICE_PER_VOTE DOUBLE,
  IS_BESTSELLER INT,
  RESTAURANT_ID INT,
  FOREIGN KEY (RESTAURANT_ID) REFERENCES RESTAURANTS(RESTAURANT_ID),
  CUISINE_ID INT,
  FOREIGN KEY (CUISINE_ID) REFERENCES CUISINES(CUISINE_ID)
);
### INSERT INTO ITEMS TABLE
INSERT INTO ITEMS (ITEM_NAME, BEST_SELLER, VOTES, PRICE, PRICE_PER_VOTE, IS_BESTSELLER, RESTAURANT_ID, CUISINE_ID)
SELECT
  ITEM_NAME,
  BEST_SELLER,
  VOTES,
  PRICES,
  PRICE_PER_VOTE,
  IS_BESTSELLER,
  RESTAURANT_ID,
  CUISINE_ID
FROM DATA AS D
JOIN RESTAURANTS AS REST ON D.RESTAURANT_NAME = REST.RESTAURANT_NAME
JOIN CUISINES AS C ON D.CUISINE = C.CUISINE_NAME;

SELECT * FROM ITEMS;

/*THIS TABLE IS DEDICATED TO MENU ITEM DETAILS. BY LINKING TO THE RESTAURANTS TABLE VIA RESTAURANT_ID AND CUISINE TABLE VIA CUISINE_ID, IT KEEPS THE ITEM-SPECIFIC DATA SEPARATE FROM RESTAURANT-SPECIFIC DATA, THEREBY REDUCING THE OVERALL SIZE AND REDUNDANCY OF THE DATASET. THIS MAKES IT EASIER TO MANAGE AND QUERY ITEM-LEVEL INFORMATION.*/

SELECT COUNT(ITEM_NAME) FROM DATA ORDER BY ITEM_NAME;

-- ITEMS TABLE HAS A LOT OF DUPLICATE VALUES.
-- THE QUERY DISPLAYS THE COUNT OF ROWS THAT ARE DUPLICATE.
SELECT COUNT(*) AS TOTAL_GROUPS
FROM (
  SELECT
    COUNT(ITEM_NAME),
    VOTES,
    PRICE,
    PRICE_PER_VOTE,
    IS_BESTSELLER,
    RESTAURANT_ID,
    CUISINE_ID,
    COUNT(*) AS DUPLICATE_COUNT
  FROM ITEMS
  GROUP BY
    ITEM_NAME,
    VOTES,
    PRICE,
    PRICE_PER_VOTE,
    IS_BESTSELLER,
    RESTAURANT_ID,
    CUISINE_ID
  HAVING
    COUNT(*) > 1
) AS GROUPED_RESULTS;

SELECT COUNT(*) FROM ITEMS;

-- THIS QUERY DELETES THE DUPLICATE ROWS.
DELETE FROM ITEMS
WHERE ITEM_ID IN (
  SELECT ITEM_ID
  FROM (
    SELECT
      ITEM_ID,
      ROW_NUMBER() OVER (
        PARTITION BY ITEM_NAME, VOTES, PRICE, PRICE_PER_VOTE, IS_BESTSELLER, RESTAURANT_ID, CUISINE_ID
        ORDER BY ITEM_ID
      ) AS RN
    FROM ITEMS
  ) AS SUBQUERY
  WHERE RN > 1
);

/*THIS QUERY IS USED TO DETECT AND COUNT THE NUMBER OF DUPLICATE GROUPS WITHIN YOUR ITEMS TABLE. IT IDENTIFIES ROWS WITH IDENTICAL VALUES ACROSS ITEM_NAME, VOTES, PRICE, PRICE_PER_VOTE, IS_BESTSELLER, RESTAURANT_ID, AND CUISINE_ID. THE FINAL RESULT, TOTAL_GROUPS, REPRESENTS THE TOTAL NUMBER OF THESE DUPLICATE ENTRIES, HIGHLIGHTING A DATA QUALITY ISSUE THAT NEEDS TO BE ADDRESSED, LIKELY BY REMOVING THE DUPLICATES.*/

-- RETRIEVE ALL RESTAURANTS IN A SPECIFIC CITY:
# 1. WRITE A SQL QUERY TO LIST ALL RESTAURANTS LOCATED IN 'JAIPUR'.
SELECT R.RESTAURANT_NAME, C.CITY_NAME
FROM RESTAURANTS AS R
JOIN CITIES AS C ON C.CITY_ID = R.CITY_ID
WHERE C.CITY_NAME = 'JAIPUR';

/*SO, THE CONCLUSION IS THAT THE OUTPUT PROVIDES A COMPREHENSIVE LIST OF ALL RESTAURANTS SPECIFICALLY LOCATED IN JAIPUR, BASED ON THE DATA IN YOUR RESTAURANTS TABLE.*/

**FIND THE AVERAGE RATING FOR EACH CUISINE TYPE:**
# 2. WRITE A SQL QUERY TO CALCULATE THE AVERAGE RATING FOR EACH CUISINE.
SELECT CUISINE_NAME, AVG_RATING_CUISINE
FROM CUISINES;

/*IT'S DESIGNED TO RETRIEVE THE PRE-CALCULATED AVERAGE RATING FOR EACH CUISINE.*/

**IDENTIFY THE TOP 5 HIGHLY-RATED RESTAURANTS:**
# 3. WRITE A SQL QUERY TO FIND THE TOP 5 RESTAURANTS WITH THE HIGHEST AVERAGE_RATING.
SELECT RESTAURANT_NAME,
  AVG_RATING_RESTAURANT AS TOP_RESTAURANTS
FROM RESTAURANTS
ORDER BY TOP_RESTAURANTS DESC
LIMIT 5;

/*THIS QUERY'S OUTPUT DIRECTLY PRESENTS THE TOP FIVE RESTAURANTS BASED ON THEIR AVERAGE RATING, ALLOWING FOR A QUICK AND CLEAR IDENTIFICATION OF THE BEST-PERFORMING ESTABLISHMENTS IN YOUR DATASET.*/
**COUNT THE NUMBER OF BEST-SELLING ITEMS FOR EACH RESTAURANT:**
# 4. WRITE A SQL QUERY TO COUNT HOW MANY BESTSELLER ITEMS EACH RESTAURANT HAS.
SELECT R.RESTAURANT_NAME,
  COUNT(I.BEST_SELLER) AS BEST_SELLING_ITEM
FROM ITEMS AS I
JOIN RESTAURANTS AS R ON R.RESTAURANT_ID = I.RESTAURANT_ID
GROUP BY RESTAURANT_NAME
ORDER BY BEST_SELLING_ITEM;

/*THIS QUERY SUMMARIZES THE BEST-SELLING ITEM COUNT FOR EACH RESTAURANT, HIGHLIGHTING WHICH ESTABLISHMENTS HAVE THE MOST POPULAR ITEMS ON THEIR MENU.TES FOR EACH ITEM, ORDERED BY POPULARITY:**

# 5. WRITE A SQL QUERY TO FIND THE TOTAL VOTES FOR EACH ITEM_NAME, ORDERED IN DESCENDING ORDER OF VOTES.
SELECT ITEM_NAME,
  R.TOTAL_VOTES AS TOTAL_VOTES
FROM ITEMS AS I
JOIN RESTAURANTS AS R ON R.RESTAURANT_ID = I.RESTAURANT_ID
ORDER BY TOTAL_VOTES DESC;

**FIND RESTAURANTS WITH BOTH HIGH DINING AND DELIVERY RATINGS:**
# 6. WRITE A SQL QUERY TO LIST RESTAURANT_NAME THAT HAVE A DINING_RATING ABOVE 4.0 AND DELIVERY_RATING ABOVE 4.0.
SELECT DISTINCT (RESTAURANT_NAME)
FROM RESTAURANTS
WHERE DINING_RATING > 4.0 AND DELIVERY_RATING > 4.0;
 /*THIS QUERY RANKS MENU ITEMS BY THEIR TOTAL VOTES, SHOWCASING THE MOST POPULAR DISHES ACROSS ALL RESTAURANTS.*/
 
**DETERMINE THE AVERAGE PRICE OF DISHES FOR EACH CITY:**
# 7. WRITE A SQL QUERY TO CALCULATE THE AVERAGE PRICES OF ITEMS IN EACH CITY.
SELECT CITY_NAME,
  AVG_PRICE_CITY AS AVERAGE_PRICES
FROM CITIES
ORDER BY AVERAGE_PRICES;
 /*THIS QUERY PROVIDES A RANKED LIST OF CITIES BY THEIR AVERAGE ITEM PRICES, MAKING IT EASY TO IDENTIFY THE MOST AND LEAST EXPENSIVE DINING LOCATIONS.*/
 
**LIST ALL ITEMS THAT ARE MARKED AS 'MUST TRY' AND THEIR PRICES:**
# 8. WRITE A SQL QUERY TO FIND ALL ITEM_NAME AND THEIR PRICES WHERE BEST_SELLER IS 'MUST TRY'.
SELECT ITEM_NAME, PRICE
FROM ITEMS
WHERE BEST_SELLER = 'MUST TRY';

# 9. WRITE A SQL QUERY TO COMPARE THE AVERAGE VOTES FOR ITEMS THAT IS_BESTSELLER (1) VERSUS THOSE THAT ARE NOT (0).
SELECT IS_BESTSELLER,
  AVG(VOTES) AS AVG_VOTES
FROM ITEMS
GROUP BY IS_BESTSELLER;

# 10. WRITE A SQL QUERY TO RANK CITY BASED ON THEIR AVG_RATING_CITY IN DESCENDING ORDER?"
SELECT CITY_NAME,
  AVG_RATING_CITY AS AVG_RATING_CITY
FROM CITIES
ORDER BY AVG_RATING_CITY DESC;
